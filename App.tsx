
import React, { useState, useCallback, useEffect, useRef } from 'react';
import KnowledgeBase from './components/KnowledgeBase';
import ChatInterface from './components/ChatInterface';
import DocsModal from './components/DocsModal';
import { DocumentItem, ChatMessage, AppStatus, ModelType, ChatAttachment } from './types';
import { performResearch, generateSpeech } from './geminiService';
import { db } from './db';
import { decode, decodeAudioData } from './audioUtils';

const STORAGE_KEYS = {
  THEME: 'nexus_theme_v1',
  MODEL: 'nexus_model_v1'
};

const App: React.FC = () => {
  const [documents, setDocuments] = useState<DocumentItem[]>([]);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isInitializing, setIsInitializing] = useState(true);

  const [selectedModel, setSelectedModel] = useState<ModelType>(() => {
    const saved = localStorage.getItem(STORAGE_KEYS.MODEL);
    return (saved as ModelType) || 'gemini-3-flash-preview';
  });

  const [isDarkMode, setIsDarkMode] = useState<boolean>(() => {
    const saved = localStorage.getItem(STORAGE_KEYS.THEME);
    return saved ? saved === 'dark' : window.matchMedia('(prefers-color-scheme: dark)').matches;
  });

  const [status, setStatus] = useState<AppStatus>(AppStatus.IDLE);
  const [useSearch, setUseSearch] = useState(true);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [isDocsOpen, setIsDocsOpen] = useState(false);
  
  const audioContextRef = useRef<AudioContext | null>(null);

  // Initialize Data from IndexedDB
  useEffect(() => {
    const initData = async () => {
      try {
        const [loadedDocs, loadedMsgs] = await Promise.all([
          db.getAllDocuments(),
          db.getAllMessages()
        ]);
        setDocuments(loadedDocs);
        setMessages(loadedMsgs.sort((a, b) => a.timestamp - b.timestamp));
      } catch (err) {
        console.error("Failed to load persistent data:", err);
      } finally {
        setIsInitializing(false);
      }
    };
    initData();
  }, []);

  // Simple LocalStorage Persistence for Settings
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.MODEL, selectedModel);
  }, [selectedModel]);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.THEME, isDarkMode ? 'dark' : 'light');
    if (isDarkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [isDarkMode]);

  const handleAddDocument = async (doc: DocumentItem) => {
    await db.addDocument(doc);
    setDocuments(prev => [...prev, doc]);
  };

  const handleRemoveDocument = async (id: string) => {
    await db.removeDocument(id);
    setDocuments(prev => prev.filter(d => d.id !== id));
  };

  const handleClearHistory = async () => {
    if (confirm("Clear all chat history? Documents in memory will be kept.")) {
      await db.clearMessages();
      setMessages([]);
    }
  };

  const handleExportSession = () => {
    if (messages.length === 0 && documents.length === 0) {
      alert("No research data to export.");
      return;
    }

    const timestamp = new Date().toLocaleString();
    let mdContent = `# Nexus Research Report\n`;
    mdContent += `**Generated on:** ${timestamp}\n`;
    mdContent += `**Model Used:** ${selectedModel === 'gemini-3-pro-preview' ? 'Gemini 3 Pro' : 'Gemini 3 Flash'}\n\n`;

    mdContent += `## ðŸ§  Knowledge Base (Memory)\n`;
    if (documents.length === 0) {
      mdContent += `*No documents uploaded.*\n\n`;
    } else {
      documents.forEach(doc => {
        mdContent += `### ðŸ“„ ${doc.name} (${doc.type})\n`;
        if (doc.type === 'image') {
          mdContent += `*[Image data attached in memory]*\n\n`;
        } else {
          mdContent += `\`\`\`${doc.type === 'json' ? 'json' : 'text'}\n${doc.content.substring(0, 1000)}${doc.content.length > 1000 ? '...' : ''}\n\`\`\`\n\n`;
        }
      });
    }

    mdContent += `## ðŸ’¬ Research Dialogue\n\n`;
    if (messages.length === 0) {
      mdContent += `*No conversation history.*\n\n`;
    } else {
      messages.forEach(msg => {
        const role = msg.role === 'user' ? 'Researcher' : 'Nexus Intelligence';
        mdContent += `#### **${role}:**\n${msg.text}\n\n`;
        if (msg.attachments) {
            msg.attachments.forEach(att => {
                mdContent += `*[Snapshot Attached]*\n`;
            });
        }
        if (msg.sources && msg.sources.length > 0) {
          mdContent += `**Sources:**\n`;
          msg.sources.forEach(src => {
            mdContent += `- [${src.title}](${src.uri})\n`;
          });
          mdContent += `\n`;
        }
        mdContent += `---\n\n`;
      });
    }

    mdContent += `\n*EOF - Generated by Nexus AI Research Agent*`;

    const blob = new Blob([mdContent], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `Nexus_Research_${new Date().toISOString().split('T')[0]}.md`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const speakResponse = async (text: string) => {
    try {
      const base64Audio = await generateSpeech(text);
      if (!audioContextRef.current) {
        audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: 24000 });
      }
      const ctx = audioContextRef.current;
      const audioBuffer = await decodeAudioData(decode(base64Audio), ctx, 24000, 1);
      const source = ctx.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(ctx.destination);
      source.start();
    } catch (e) {
      console.error("Auto-speak failed", e);
    }
  };

  const handleSendMessage = useCallback(async (text: string, attachments: ChatAttachment[] = [], autoSpeak: boolean = false) => {
    const userMsg: ChatMessage = {
      id: Date.now().toString(),
      role: 'user',
      text,
      attachments,
      timestamp: Date.now()
    };

    // Optimistic Update
    setMessages(prev => [...prev, userMsg]);
    db.addMessage(userMsg).catch(console.error);

    setStatus(AppStatus.LOADING);

    try {
      const { text: responseText, sources } = await performResearch(
        text,
        [...messages, userMsg], // Pass updated history manually since state update is async
        documents,
        selectedModel,
        attachments, // Pass immediate visual context
        useSearch
      );

      const aiMsg: ChatMessage = {
        id: (Date.now() + 1).toString(),
        role: 'model',
        text: responseText,
        sources,
        timestamp: Date.now()
      };

      setMessages(prev => [...prev, aiMsg]);
      db.addMessage(aiMsg).catch(console.error);
      setStatus(AppStatus.IDLE);

      if (autoSpeak) {
        speakResponse(responseText);
      }

    } catch (error) {
      console.error("Research Error:", error);
      const errorMsg: ChatMessage = {
        id: (Date.now() + 1).toString(),
        role: 'model',
        text: "Research cycle interrupted. Check your API key or data volume.",
        timestamp: Date.now()
      };
      setMessages(prev => [...prev, errorMsg]);
      db.addMessage(errorMsg).catch(console.error);
      setStatus(AppStatus.ERROR);
    }
  }, [messages, documents, useSearch, selectedModel]);

  if (isInitializing) {
    return (
       <div className="flex h-screen w-full items-center justify-center bg-slate-50 dark:bg-zinc-950">
          <div className="flex flex-col items-center gap-4">
             <div className="w-12 h-12 border-4 border-indigo-500/30 border-t-indigo-500 rounded-full animate-spin"></div>
             <p className="text-slate-400 dark:text-zinc-500 text-xs font-bold uppercase tracking-widest animate-pulse">Initializing Nexus Memory...</p>
          </div>
       </div>
    );
  }

  return (
    <div className={`flex h-screen w-full overflow-hidden transition-colors duration-300 ${isDarkMode ? 'dark bg-zinc-950' : 'bg-white'}`}>
      {/* Modals */}
      <DocsModal isOpen={isDocsOpen} onClose={() => setIsDocsOpen(false)} />

      {/* Mobile Backdrop */}
      {isSidebarOpen && (
        <div 
          className="fixed inset-0 bg-slate-900/60 z-40 md:hidden backdrop-blur-md transition-opacity"
          onClick={() => setIsSidebarOpen(false)}
        />
      )}

      {/* Knowledge Base Sidebar */}
      <KnowledgeBase 
        documents={documents} 
        onAddDocument={handleAddDocument} 
        onRemoveDocument={handleRemoveDocument} 
        isOpen={isSidebarOpen}
        onClose={() => setIsSidebarOpen(false)}
        onClearHistory={handleClearHistory}
        onExportSession={handleExportSession}
        onOpenDocs={() => setIsDocsOpen(true)}
      />

      {/* Main Chat Interface */}
      <div className="flex-1 flex flex-col min-w-0 h-full">
        <ChatInterface 
          messages={messages} 
          status={status} 
          useSearch={useSearch}
          setUseSearch={setUseSearch}
          selectedModel={selectedModel}
          onModelChange={setSelectedModel}
          onSendMessage={handleSendMessage} 
          onToggleSidebar={() => setIsSidebarOpen(!isSidebarOpen)}
          isDarkMode={isDarkMode}
          onToggleTheme={() => setIsDarkMode(!isDarkMode)}
        />
      </div>
    </div>
  );
};

export default App;
